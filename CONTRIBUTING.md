Plunder functions in 3 steps:



# Process

1. **Instruments** implement an interface that outputs a stream of audio samples & is modified by generic events.
  + For example, the **wav-reader** instrument uses events like **play**, **pause**, **resume**, **stop**
  + For example, the **midi-synth** instrument uses events like **C5**, **Eb6 0.5** (Eb on 5th octave played at 50% velocity)

  <details>
    <summary>Further Reading</summary>

  Every event an instrument exports, it actually also exports a shared reference to itself (`<I: Instrument>(Arc<RwLock<I>, I::Event)`). This allows the instruments to no longer need to be tended to and the events can independently participate in the parsing (next step)

  How a constructed instrument makes it into [`plunder.lua`](#plunderlua) is currently upto the author of the instrument and may be included in a PR

  </details>


2. **Parsers** implement an interface that reads a pattern-string and produces a *list of dynamic events* and when to invoke them. They may also be extended with more arguments to *build* them up

  + For example, the **default-parser**, a very general-purpose parser, uses a map of what event to trigger at what position a string (needle) is encountered in the pattern-string
    <details>
      <summary>Example</summary>

    ```lua
    kick  = plunder.load 'kick.wav'
    crash = plunder.load 'crash.wav'
    
    beat  = plunder {
      '!   !   !  !  ! ',
      '|-->|-->|> |> |>'
    }

    beat [1] { ['!'] = kick.start }                      -- events: (a...b...c..d..e.)
    beat [2] { ['|'] = crash.start, ['>'] = crash.stop } -- events: (a..bc..def.gh.ij)
    ```
    </details>

  + For example, the **piano-note-parser** parses notes directly from the pattern-string and does not use any arguments
    <details>
      <summary>Example</summary>

    ```lua
    piano  = plunder.load 'piano.sf2'
    melody = plunder 'C5 Eb5 G5 Bb5 D6 Bb5 G5 D#5'
    melody << piano:note_parser -- use this parser instead of the default-parser
    -- this parser knows not to complain if no arguments were passed to it before flattening the grid, the default-parser however would have complained
    melody:play(3) -- events: ([C5]..[Eb5]..[G5]..[Bb5]..[D6]..[Bb5]..[G5]..[D#5]..)
    ```
    </details>


3. The **Engine** consumes the *"list of dynamic events"* generated by the **parser** to render the sequence of audio-samples as outputted by each instrument, blended with the audio-samples outputted by all other instruments in the same grid. Intruments are lazily loaded into the engine after the first event extracted from them is encountered. The engine can be ran by invoking `play` on a grid.



# `plunder.lua`

A Lua file is still used in the library to assemble the heavy parts written in Rust. This is the main entrypoint of the library and brings in [`libplunder`](#libplunderso). This decision should allow users familiar with Lua to tweak the library to a certain extent, without having to recompile the entire library.



# `libplunder.so`

Various compoenents of plunder, including ones that require interfacing with external systems (audio, file processing, etc.) are written in Rust and compiled as a Lua module with generous help from [`mlua`](https://github.com/mlua-rs/mlua), into `libplunder.so`.
